# 🐎 Horse Racing Game Asset Specifications

본 문서는 `horse-race-multiplayer.html` 개발을 위해 생성된 시각 리소스의 기술 규격 및 구현 가이드입니다.

---

## 1. 말 애니메이션 스프라이트 (Horse Sprites)
* **저장 경로:** `assets/horses/horse_1.png` ~ `horse_6.png`
* **파일 형식:** 배경이 투명한 PNG (Alpha Channel 포함)
* **이미지 규격:**
    * **프레임 크기:** 단일 프레임 기준 **300x300px** 권장
    * **애니메이션 구성:** 가로로 나열된 **8프레임**의 Run-cycle (달리는 동작)
    * **방향:** 모든 말은 오른쪽(Right)을 향해 달리는 사이드뷰
* **구현 가이드:**
    * CSS `background-position`과 `steps(8)`를 사용하여 무한 루프 애니메이션을 생성하십시오.
    * 서버에서 전달받은 `speed` 파라미터에 따라 `animation-duration`을 실시간으로 조절하여 속도 차이를 구현하십시오.

## 2. 경기장 트랙 (Race Track Background)
* **저장 경로:** `assets/backgrounds/race_track.png`
* **규격:** 좌우 끝이 매끄럽게 연결되는 **심리스(Seamless)** 이미지
* **특징:** 상단과 하단에 울타리(Fence)가 포함된 16비트 픽셀 아트 스타일
* **구현 가이드:**
    * `background-repeat: repeat-x` 속성을 사용하여 가로로 무한히 이어지는 트랙을 구현하십시오.
    * 말의 전진 속도와 배경의 스크롤 속도를 동기화하여 미끄러짐 현상을 방지하십시오.

## 3. UI 컴포넌트 (UI Assets)
* **나무 패널 (`ui_panel.png`):** 픽셀 아트 스타일의 우드 보드 이미지
    * **용도:** 베팅 현황창, 결과 순위 팝업, 게임 룰 안내 창의 배경
* **Fallback 로직:** 이미지 로딩에 실패하거나 파일이 없을 경우, 기본값으로 🐎(말 이모지) 또는 CSS로 구현된 기본 형태를 사용하십시오.

## 4. 로직 통합 핵심 포인트 (For Cursor Logic)
* **애니메이션 동기화:** 모든 말의 도착 시간과 순위 파라미터는 **서버(`server.js`)에서 결정**된 데이터를 기반으로 하며, 클라이언트는 이를 시각적으로 재생만 해야 합니다.
* **중복 선택 방지:** 말의 수가 참가자 수보다 많거나 같을 경우, 서버 검증을 통해 동일한 말의 중복 선택을 차단하고 UI상에서 해당 말은 비활성화(Grayscale 처리)하십시오.
* **재경주 로직:** 당첨자가 2명 이상일 경우, `raceRound`를 증가시키고 해당 인원들만 다시 말을 선택할 수 있는 라운드 초기화 로직을 실행하십시오.

## 5. 탈것 상태별 애니메이션

`getVehicleSVG(vehicleId)` 함수는 각 탈것별로 5가지 상태 모션을 지원합니다.

### 데이터 구조
```javascript
svgMap['horse'] = {
    idle:    { frame1, frame2 },  // 대기 모션
    run:     { frame1, frame2 },  // 달리기 모션 (기존)
    finish:  { frame1, frame2 },  // 도착 모션
    victory: { frame1, frame2 },  // 승리 모션 (왕관 포함)
    dead:    { frame1, frame2 },  // 꼴등 사망 (비석+유령)
    // getter로 frame1/frame2 직접 접근 시 run 반환 (하위호환)
}
```

### 상태별 모션 설명
| 상태 | 모션 | 특징 |
|------|------|------|
| idle | 발구르기 + 머리 끄덕 | 다리 모두 땅, 꼬리 늘어짐 |
| run | 전력 질주 | 다리 교차, 갈기/꼬리 날림 |
| finish | 천천히 걷기 | 다리 간격 좁게, 느린 전환 |
| victory | 앞발 들기 (히힝!) | 왕관, 반짝이 이펙트, 입 벌림 |
| dead | 비석 R.I.P | 반투명 유령 + X눈, 풀 장식 |

## 6. 트랙 오브젝트

`getTrackObjectSVG(objectId)` 함수로 13종 오브젝트 SVG를 가져옵니다.

### 경주장 시설물 (3종)
| objectId | viewBox | 설명 |
|----------|---------|------|
| start-gate | 80×75 | 4칸 출발 게이트 (번호 표시) |
| fence | 60×12 | 나무 울타리 (repeat-x 가능) |
| grandstand | 120×60 | 3열 관중석 + 깃발 |

### 장애물 (3종)
| objectId | viewBox | 연동 기믹 |
|----------|---------|----------|
| rock | 30×25 | stop/slow |
| puddle | 35×15 | slip |
| hurdle | 25×30 | wobble |

### 부스트 아이템 (3종)
| objectId | viewBox | 연동 기믹 |
|----------|---------|----------|
| carrot | 20×30 | sprint |
| star | 25×25 | 특수효과 |
| horseshoe | 25×25 | 행운 |

### 배경 장식 (4종)
| objectId | viewBox | 용도 |
|----------|---------|------|
| tree | 30×50 | 트랙 주변 나무 |
| flower | 15×20 | 트랙 가장자리 |
| checkered-flag | 20×30 | 결승선 |
| balloon | 15×25 | 관중석 장식 |

## 7. 리소스 생성 지침
* **AI 지침 활용:** 제미나이에서 받은 리소스 생성 지침을 기반으로 제작 가능합니다.
  결과물은 본 문서의 규격에 맞춰 `assets/` 경로에 저장하십시오.


  다음 규격으로 2D 게임용 스프라이트를 그려주세요:

1. 탈것 스프라이트 (각 탈것마다 2프레임):
   - 크기: 240px × 180px (4:3 비율)
   - 프레임1: 달리는 자세 1
   - 프레임2: 달리는 자세 2
   - 탈것 종류: 자동차, 로켓, 새, 보트, 자전거, 토끼, 거북이, 독수리, 킥보드, 헬리콥터
   - 방향: 오른쪽을 향함
   - 스타일: 심플한 2D 일러스트

2. 트랙 배경 (10종류):
   - 크기: 1400px × 150px
   - 각 탈것에 맞는 배경 (고속도로, 우주, 하늘, 바다 등)
   - 가로로 긴 형태

3. 벽(경계선):
   - 크기: 1400px × 12px
   - 입체적인 벽 느낌


   전체 화면 배경은 게임 캔버스를 감싸는 연한 회색/화이트 톤을 유지하고,
트랙 레인 하나당 높이는 약 75px(벽 포함 81px), 벽은 6px 높이의 짙은 회색 그라데이션으로 구분선을 넣습니다.
개별 탈것 스프라이트는 width 60px × height 45px (SVG viewBox 0 0 60 45)이며, 제미나이에게는 4:3 비율로 240px × 180px(또는 120px × 90px) 2프레임 달리기 모습을 요청하세요.

크기/비율
클라이언트는 width: 60px, height: 45px, viewBox="0 0 60 45"로 렌더링합니다.
따라서 이미지를 60×45px (4:3 비율)으로 맞추거나, 120×90 / 240×180처럼 2배/4배 스케일로 만들어도 됩니다.
비율만 4:3로 유지하면 CSS에서 자동 축소/확대 가능.
프레임 구성
애니메이션은 2프레임입니다. 제미나이에게 “frame1/ frame2” 두 가지 포즈를 따로 PNG/SVG로 주세요.
둘 다 오른쪽 방향, 배경 투명(알파)으로 만들어야 트랙 위에 자연스럽게 배치됩니다.
포즈
달리는 느낌이 나도록 다리가 다른 위치에 놓이게 하고, 몸통/머리 방향은 오른쪽으로 향하게 합니다.
프레임 간 움직임이 단순히 옆으로 스와이프만 되지 않도록 다리/꼬리/바퀴 위치를 살짝 바꿔주세요.
컬러/경계
지금처럼 흰색 배경 대신 투명 배경 쓰면 트랙 색상을 그대로 보여줄 수 있습니다.
테두리는 살짝 픽셀 아웃라인을 넣으면 다른 오브젝트와 대비되어 좋아요.