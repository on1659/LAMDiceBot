# Railway 제약 안에서 현실적 기능 확장

## 프로젝트 컨텍스트
- **플랫폼**: LAMDiceBot (Node.js + Express + Socket.IO)
- **호스팅**: Railway (무료 티어 $5/월, 단일 인스턴스, ephemeral FS)
- **게임**: 주사위, 경마, 룰렛, 팀 배정
- **기술 스택**: vanilla JS, PostgreSQL, Gemini AI, GPT 커스텀 룰
- **공유 모듈**: ChatModule, order-shared, ready-shared, sound-manager

---

## 1. 실시간 동시접속자 대시보드

**🎯 기획자**: 관리자가 현재 접속자 수, 각 게임방별 인원, 활동 통계를 실시간으로 볼 수 있는 대시보드가 있으면 좋겠어요. 운영 현황 파악하고 인기 게임도 분석할 수 있잖아요.

**💻 프로그래머**: Socket.IO로 실시간 접속자 추적은 이미 구현되어 있어요. 각 room의 `io.sockets.adapter.rooms`를 쿼리하면 현재 인원 파악 가능합니다. 다만 Railway 단일 인스턴스라서 동시접속 50명 넘어가면 메모리 압박이 시작될 거예요.

**🎯 기획자**: 50명이면... 그렇게 많지 않네요. 대시보드 자체는 무겁지 않을 것 같은데요?

**💻 프로그래머**: 대시보드 페이지 하나 추가하는 건 간단합니다. `/admin/dashboard` 라우트 만들고 Socket.IO로 1초마다 통계 브로드캐스트하면 돼요. 메모리 사용량도 `process.memoryUsage()`로 모니터링 가능하고요. 다만 인증 없이 공개하면 누구나 접근 가능하니 간단한 API 키나 비밀번호 보호는 필요할 것 같아요.

**🎯 기획자**: 좋아요! 간단한 비밀번호로 보호하고, 접속자 수와 메모리 사용량만 보여주는 걸로 시작하죠.

---

## 2. 게임 결과 영구 저장 & 통계

**🎯 기획자**: 지금은 게임 결과가 `play-stats.json`에 저장되는데, Railway는 파일시스템이 휘발성이라고 했잖아요. 재시작하면 다 날아가는 거 아닌가요? 사용자들이 자기 승률 보고 싶어 할 텐데요.

**💻 프로그래머**: 맞습니다. ephemeral FS라서 재배포나 슬립 모드 해제 시 파일 날아가요. 근데 PostgreSQL은 이미 사용 가능하다고 하셨으니, 간단한 `game_results` 테이블 만들어서 저장하면 됩니다. 게임 종류, 플레이어 이름, 결과, 타임스탬프 정도만 저장해도 충분할 거예요.

**🎯 기획자**: 그럼 각 플레이어별 승률, 총 게임 수, 최근 전적 같은 통계도 보여줄 수 있겠네요?

**💻 프로그래머**: 네, SQL 쿼리로 집계 가능합니다. 다만 Railway 무료 티어에서 DB 용량 제한이 있을 수 있으니, 오래된 데이터는 주기적으로 삭제하거나 요약 통계로 변환하는 전략 필요할 수 있어요. 예를 들어 30일 이상 된 데이터는 일별 집계로 변환하는 식으로요.

**🎯 기획자**: 알겠어요. 일단 기본 통계부터 구현하고, DB 용량 보면서 최적화하는 걸로 하죠.

---

## 3. 예약 게임 (스케줄링)

**🎯 기획자**: 사용자들이 특정 시간에 게임을 예약하고, 그 시간이 되면 자동으로 게임방이 열리고 알림이 가면 재밌을 것 같아요. 정기 토너먼트 같은 것도 가능하잖아요.

**💻 프로그래머**: 아이디어는 좋은데 Railway 환경에서 큰 문제가 있어요. Railway는 트래픽 없으면 자동으로 슬립 모드에 들어가는데, 슬립 상태에서는 cron job이 실행 안 됩니다. 외부에서 HTTP 요청이 와야 깨어나요.

**🎯 기획자**: 그럼... 외부 서비스에서 주기적으로 핑을 보내면 안 될까요?

**💻 프로그래머**: 가능은 한데 비효율적이에요. UptimeRobot 같은 무료 모니터링 서비스로 5분마다 핑 보낼 수 있지만, 그러면 슬립 모드의 비용 절감 효과가 사라져요. 차라리 사용자가 예약하면 DB에 저장해두고, 다음 방문 시 "30분 뒤 예약된 게임이 있습니다" 알림을 보여주는 게 현실적일 것 같아요. 자동 시작은 아니지만 리마인더 역할은 하죠.

**🎯 기획자**: 아쉽지만... 그게 Railway에서는 최선이겠네요. 알림 기능만이라도 추가하죠.

---

## 4. 게임 공유 링크 & QR코드

**🎯 기획자**: 사용자가 게임방을 만들면 고유 링크를 생성하고, QR코드로도 공유할 수 있으면 모바일에서 참여하기 편할 것 같아요. 친구들한테 카톡으로 QR 이미지 보내면 바로 들어오는 거죠.

**💻 프로그래머**: 이건 Railway 제약과 무관하게 구현 가능해요. 게임방 ID를 URL 파라미터로 넘기는 건 이미 하고 있고, QR코드는 서버 사이드에서 `qrcode` npm 패키지로 생성하거나 클라이언트에서 `qrcode.js` 같은 라이브러리로 바로 그릴 수 있어요.

**🎯 기획자**: Railway 도메인 주소가 좀 길지 않나요? 짧은 커스텀 도메인 붙이면 QR코드가 더 단순해지지 않을까요?

**💻 프로그래머**: Railway는 기본적으로 `your-app.up.railway.app` 형태의 도메인을 제공하는데, 커스텀 도메인 연결도 지원해요. 다만 도메인 구입 비용은 별도로 발생하고(연간 $10-15), 무료 티어 내에서는 기본 도메인으로도 충분히 작동합니다. QR코드 복잡도는 URL 길이에 영향 받지만, 짧은 room ID 사용하면 큰 문제 없을 거예요.

**🎯 기획자**: 그럼 일단 기본 도메인으로 QR코드 생성 기능부터 만들고, 나중에 필요하면 커스텀 도메인 고려하죠.

---

## 5. Gemini AI 활용 확장

**🎯 기획자**: 지금 Gemini AI가 채팅봇으로만 쓰이는데, 게임 실황중계나 결과 분석 멘트도 AI가 생성하면 더 재밌을 것 같아요. "3번 말이 선두를 달리고 있습니다!" 같은 거요.

**💻 프로그래머**: Gemini AI API는 무료 티어에서 분당 15 요청, 일일 1500 요청 제한이 있어요. 채팅봇만 써도 활발한 게임 세션에서는 한도 근접할 수 있는데, 실황중계까지 추가하면 금방 초과할 거예요. 실황은 1초마다 업데이트될 수도 있으니까요.

**🎯 기획자**: 그럼 실시간은 포기하고, 게임 종료 후 결과 요약만 AI로 생성하는 건 어떨까요? "오늘은 5번 말의 날이었습니다. 압도적인 속도로 우승!" 이런 식으로요.

**💻 프로그래머**: 그건 현실적이에요. 게임당 1번만 호출하면 되니까 API 한도 걱정 없고, 결과 데이터 JSON으로 넘겨서 자연어 분석 생성하게 하면 됩니다. 경마 결과, 주사위 패턴, 룰렛 당첨 번호 통계 등을 재밌는 멘트로 만들어주는 거죠. 캐싱도 가능하고요.

**🎯 기획자**: 완벽해요! 게임 결과 화면에 AI 코멘트 섹션 추가하는 걸로 하죠.

**💻 프로그래머**: 한 가지 더, Gemini API 키는 환경변수로 관리해야 하는데, Railway에서는 `.env` 파일이 아니라 웹 대시보드에서 환경변수 설정하는 게 안전해요. Git에 키가 올라가는 걸 방지할 수 있어요.

---

## 6. 오프라인 폴백 모드

**🎯 기획자**: Railway 서버가 다운되거나 슬립 모드일 때, 사용자가 아예 게임을 못하면 너무 아쉬워요. 로컬에서라도 싱글 플레이나 로컬 멀티플레이 모드로 동작하면 안 될까요?

**💻 프로그래머**: Service Worker와 PWA 기술 쓰면 가능은 해요. 서버 연결 실패 시 브라우저 로컬스토리지나 IndexedDB 사용해서 오프라인 모드로 전환하는 거죠. 다만 멀티플레이는 중앙 서버 없이는 불가능하고, 같은 WiFi 내에서 WebRTC P2P 연결 시도할 수도 있지만 구현 복잡도가 엄청 높아요.

**🎯 기획자**: 그럼 싱글 플레이만이라도요? 혼자서 주사위 던져보거나 룰렛 연습하는 거요.

**💻 프로그래머**: 그건 현실적입니다. 각 게임의 로직을 클라이언트 사이드에서도 실행 가능하게 분리하면 돼요. 지금은 서버에서 결과 계산하지만, 클라이언트에서도 똑같은 로직 돌릴 수 있게 모듈화하는 거죠. Service Worker로 HTML/CSS/JS 캐싱하면 오프라인에서도 앱 열리고, "오프라인 모드" 배너 띄우면서 싱글 플레이 제공할 수 있어요.

**🎯 기획자**: PWA로 홈 화면 추가도 가능하다고 들었어요. 앱처럼 쓸 수 있는 거죠?

**💻 프로그래머**: 맞아요. `manifest.json` 추가하고 아이콘 설정하면 모바일에서 "홈 화면에 추가" 가능해요. 다만 PWA 전체 구현은 Service Worker 라이프사이클 관리, 캐시 전략, 업데이트 처리 등 신경 쓸 게 많아서 "PWA lite" 정도로 시작하는 게 좋을 것 같아요. 오프라인 캐싱과 manifest만 먼저 추가하고, 푸시 알림 같은 고급 기능은 나중에요.

**🎯 기획자**: 좋아요. 단계적으로 접근하는 게 맞는 것 같아요.

---

## 우선순위 합의표

| 순위 | 기능 | 구현 난이도 | Railway 비용 영향 | 사용자 가치 | 비고 |
|------|------|-------------|-------------------|-------------|------|
| 1 | 게임 결과 영구 저장 & 통계 | 중 | 낮음 (PostgreSQL 기본 제공) | 높음 | DB 마이그레이션 필요 |
| 2 | 게임 공유 링크 & QR코드 | 낮음 | 없음 | 높음 | 빠른 구현 가능 |
| 3 | Gemini AI 결과 분석 | 중 | 없음 (무료 한도 내) | 중 | API 키 환경변수 관리 필수 |
| 4 | 실시간 접속자 대시보드 | 낮음 | 낮음 (메모리 증가 미미) | 중 | 관리자용, 인증 필요 |
| 5 | 오프라인 폴백 모드 (PWA lite) | 높음 | 없음 | 중 | Service Worker 학습 필요 |
| 6 | 예약 게임 알림 | 중 | 없음 | 낮음 | 자동 시작 불가, 리마인더만 |

### Railway 무료 티어 한계 요약
- **동시접속**: ~50명 (메모리 512MB 기준)
- **월 크레딧**: $5 (약 500시간 실행 가능)
- **슬립 모드**: 비활성 5분 후 자동 슬립 (첫 요청 시 콜드 스타트 3-5초)
- **DB 용량**: PostgreSQL 무료 플랜 제한 확인 필요
- **네트워크**: 송수신 대역폭 제한 있음 (대용량 파일 전송 주의)

### 다음 단계
1. **1순위**: PostgreSQL 스키마 설계 및 `play-stats.json` 마이그레이션
2. **2순위**: QR코드 생성 API 엔드포인트 추가
3. **3순위**: Gemini AI 결과 분석 프롬프트 작성 및 테스트
4. **모니터링**: Railway 대시보드에서 메모리/크레딧 사용량 주기적 확인

---

**최종 합의**: Railway 제약을 존중하면서도 사용자 경험을 개선할 수 있는 현실적인 기능 확장 방향을 수립했습니다. 파일 저장 대신 PostgreSQL 활용, 슬립 모드 고려한 예약 시스템, 무료 API 한도 내 AI 활용, 오프라인 대응을 통해 안정적이고 지속 가능한 서비스를 만들어갑니다.
